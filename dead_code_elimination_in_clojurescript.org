#+TITLE: Notes on Dead Code Elimination in ClojureScript
#+AUTHOR: Andrew Mcveigh
#+EMAIL: me@andrewmcveigh.com
#+LANGUAGE: en

* Motivation

  I maintain `cljs-time`, a date and time library for ClojureScript,
  imitating the API of the `clj-time` library.

  Unfortunately, it suffers from a problem with dead code elimination.

  David Nolen suggested it's due the library's use of top-level data
  structures[1].

[1] https://github.com/andrewmcveigh/cljs-time/issues/21


https://developers.google.com/closure/compiler/docs/limitations?hl=en

** Compiler Options

#+BEGIN_SRC clojure :tangle no
{:cache-analysis false
 :main 'cljs-time.dce-compile-test
 :output-to "target/dce-test.js"
 :optimizations :advanced
 :pseudo-names true
 :pretty-print true
}

#+END_SRC

** Observations

** Baseline

Using the following compiler options the

80.27K minimized ~= 368.51K with `:pseudo-names` & `:pretty-print`

A function that isn't called is removed

    boot.user=> (test-dce)
    3.05K

    (def parsers
      [:date-element-parser :date-opt-time :date-parser :date-time-parser
       :local-date-opt-time :local-date :local-time :time-element-parser
       :time-parser])

    boot.user=> (test-dce)
    3.05K

    + (.log js/console parsers)

    boot.user=> (test-dce)
    364.40K

    + (def parsers
    +   #js [:date-element-parser :date-opt-time :date-parser :date-time-parser
    +        :local-date-opt-time :local-date :local-time :time-element-parser
    +        :time-parser])

    boot.user=> (test-dce)
    3.05K

    + (.log js/console parsers)

    + (def parsers
    +   ["date-element-parser" "date-opt-time" "date-parser" "date-time-parser"
    +    "local-date-opt-time" "local-date" "local-time" "time-element-parser"
    +    "time-parser"])
   
    boot.user=> (test-dce)
    3.05K

    + (.log js/console parsers)

    boot.user=> (test-dce)
    363.83K

    boot.user=> (test-dce)
    364.30K

    (def parsers
      #js ["date-element-parser" "date-opt-time" "date-parser" "date-time-parser"
           "local-date-opt-time" "local-date" "local-time" "time-element-parser"
           "time-parser"])

    boot.user=> (test-dce)
    3.05K

    + (.log js/console parsers)

    boot.user=> (test-dce)
    3.21K

## Conclusion

A top-level vector that isn't referenced will be removed in DCE.

A top-level vector that is referenced will pull in everything in `cljs.core`,
and possibly everything in a `require`.

A referenced top-level native-js array containing clojurescript keywords will
pull in everything.

A referenced top-level native-js array containing strings will not
pull in anything extra.

    (def formatters {})
    
    boot.user=> (test-dce)
    3.05K

    + (.log js/console formatters)

    boot.user=> (test-dce)
    363.63K

    (def formatters #js {})

    boot.user=> (test-dce)
    3.05K

    + (.log js/console formatters)

    boot.user=> (test-dce)
    3.07K

    (def formatters #js {:test 8})

    boot.user=> (test-dce)
    3.05K

    + (.log js/console formatters)

    boot.user=> (test-dce)
    3.07K

    (def formatters #js {:test {:test2 []}})

    boot.user=> (test-dce)
    3.05K

    + (.log js/console formatters)

    boot.user=> (test-dce)
    363.75K

    (defn formatters []
      {:something ["something"]})

    boot.user=> (test-dce)
    3.05K

    + (.log js/console formatters)

    boot.user=> (test-dce)
    363.82K

## Conclusion

ClojureScript data structures require quite a large amount of js

    (ns cljs-time.dce-compile-test
      (:require
       [cljs-time.core :as time]))
    
    boot.user=> (test-dce)
    6.33K

    (.log js/console (time/date-time 2014))

    boot.user=> (test-dce)
    25.70K

    (.log js/console (time/plus (time/date-time 2014) (time/months 1)))

    boot.user=> (test-dce)
    451.86K
    ; or without :pseudo-names & :pretty-print
    101.79K

## Whoa!

    (ns cljs-time.core
      (:refer-clojure :exclude [= extend second])
      (:require
       [cljs-time.internal.core :as internal :refer [leap-year? format]]
       [clojure.string :as string]
       goog.date.Interval)
      (:import
       goog.date.Date
       goog.date.DateTime
       goog.date.UtcDateTime))

boot.user=> (test-dce)
2.27K

boot.user=> (test-dce)
79.96K

# TODO

 * Get a base size for cljs
 * Decide which optimization to measure
 * Write the whole thing in code / literal style!




* The Test

The test consists of a Clojure source file in the form of a `build.boot` script.

#+BEGIN_SRC clojure :tangle build.boot

(set-env!
 :source-paths #{"src"}
 :dependencies '[[org.clojure/clojure "1.7.0"]
                 [org.clojure/clojurescript "1.7.228"]])

(require '[cljs.build.api :as cljs])
(require '[cljs.closure :as closure])
(require '[clojure.java.io :as io])

#+END_SRC

Using the following compiler options:

#+BEGIN_SRC clojure :tangle build.boot

(def compiled-file "target/compiled.min.js")

(def compiler-opts
  {:cache-analysis true
   :output-to compiled-file
   :optimizations :advanced})

#+END_SRC

The function `compile-size` compiles the source and prints the size of
the compiled source in KB to the console. The function is run from the REPL.

#+BEGIN_SRC clojure :tangle build.boot

(defn compile-size [namespace]
  (let [uri (:uri (closure/cljs-source-for-namespace namespace))
        all-compiler-opts (assoc compiler-opts :main namespace)
        js (cljs/build uri all-compiler-opts)
        length (.length (io/file compiled-file))]
    (println (format "%.2fK" (double (/ length 1024))))))

#+END_SRC

We'll begin with a couple of baseline tests to determine the base size
of compiled ClojureScript.

#+BEGIN_SRC clojure :tangle src/cljs_time/base_1.cljs
(ns cljs-time.base-1)
#+END_SRC

#+BEGIN_SRC clojure :tangle no
boot.user=> (compile-size 'cljs-time.base-1) ; => 1.19K
#+END_SRC

#+BEGIN_SRC clojure :tangle src/cljs_time/base_1.cljs
(def something {})
#+END_SRC

#+BEGIN_SRC clojure :tangle no
boot.user=> (compile-size 'cljs-time.base-1) ; => 1.19K
#+END_SRC

#+BEGIN_SRC clojure :tangle src/cljs_time/base_1.cljs
(.log js/console something)
#+END_SRC

#+BEGIN_SRC clojure :tangle no
boot.user=> (compile-size 'cljs-time.base-1) ; => 78.32K
#+END_SRC

OK, what's that?

#+BEGIN_SRC bash :tangle no
$ ls -lh target/
total 160
-rw-r--r--  1 andrew.mcveigh  staff    78K 18 Jan 20:47 compiled.min.js
#+END_SRC

What size would that be gzipped?

#+BEGIN_SRC bash :tangle no
$ gzip target/compiled.min.js

$ ls -lh target/
total 40
-rw-r--r--   1 andrew.mcveigh  staff    18K 18 Jan 20:42 compiled.min.js.gz
#+END_SRC

That's 18K, and that's exactly the size of optimized and gzipped
ClojureScript[2]. We can also say then, that compiled, optimized
ClojureScript is 78K.

There are two things to note so far: that there is 1.19K overhead
before ClojureScript is compiled in, and that top-level datastructures
don't cost anything until they are referenced. The DCE removes the
from the compiled artifact. Once you actually need it, you're getting
all of ClojureScript.


** cljs-time

   Recently I re-wrote some of `cljs-time.core` to take advantage of
   the date addition functionality in `goog.date`, replacing some
   custom code containing a few subtle bugs.

   Dynamically dispatching functions using a Clojure(Script) `map` is
   a common pattern in clojure. Unfortunately, in ClojureScript this
   can defeat DCE[1].

#+BEGIN_SRC clojure :tangle src/cljs_time/core_1.cljs
(ns cljs-time.core-1
  (:import
   [goog.date Interval]))

(def period-fns
  {:millis (fn [date op value]
             (let [ms (op (.getTime date) value)]
               (doto date (.setTime ms))))
   :weeks  (fn [date op value]
             (let [days (op 0 (* value 7))]
               (doto date
                 (.add (Interval. Interval.DAYS days)))))})

(def periods
  {:seconds Interval.SECONDS
   :minutes Interval.MINUTES
   :hours   Interval.HOURS
   :days    Interval.DAYS
   :months  Interval.MONTHS
   :years   Interval.YEARS})

#+END_SRC

#+BEGIN_SRC clojure :tangle src/cljs_time/base_2.cljs
(ns cljs-time.base-2
  (:require [cljs-time.core-1 :as time]))
#+END_SRC

#+BEGIN_SRC clojure :tangle no
boot.user=> (compile-size 'cljs-time.base-2) ; => 1.19K
#+END_SRC

#+BEGIN_SRC clojure :tangle src/cljs_time/base_2.cljs
(.log js/console (time/period-fns :weeks))
#+END_SRC

#+BEGIN_SRC clojure :tangle no
boot.user=> (compile-size 'cljs-time.base-2) ; => 78.40K
#+END_SRC

Again, we see the same behaviour. The top-level maps have no cost
until they are referenced. Once referenced they are compiled in, and
also pull in ClojureScript. In this case it seems `period-fns`
adds and extra 0.08K.

#+BEGIN_SRC clojure :tangle src/cljs_time/core_2.cljs
(ns cljs-time.core-2
  (:require
   [clojure.string :as string])
  (:import
   [goog.date Interval]))

(def period-fns
  {:millis (fn [date op value]
             (let [ms (op (.getTime date) value)]
               (doto date (.setTime ms))))
   :weeks  (fn [date op value]
             (let [days (op 0 (* value 7))]
               (doto date
                 (.add (Interval. Interval.DAYS days)))))})

(def periods
  {:seconds Interval.SECONDS
   :minutes Interval.MINUTES
   :hours   Interval.HOURS
   :days    Interval.DAYS
   :months  Interval.MONTHS
   :years   Interval.YEARS})

#+END_SRC

#+BEGIN_SRC clojure :tangle src/cljs_time/base_3.cljs
(ns cljs-time.base-3
  (:require [cljs-time.core-2 :as time]))
#+END_SRC

#+BEGIN_SRC clojure :tangle no
boot.user=> (compile-size 'cljs-time.base-2) ; => 1.19K
#+END_SRC

#+BEGIN_SRC clojure :tangle src/cljs_time/base_3.cljs
(.log js/console (time/period-fns :weeks))
#+END_SRC

#+BEGIN_SRC clojure :tangle no
boot.user=> (compile-size 'cljs-time.base-2) ; => 79.11K
#+END_SRC

[1] https://github.com/andrewmcveigh/cljs-time/issues/21
[2] http://stuartsierra.com/2012/06/16/why-im-using-clojurescript
